# 프로젝트 가이드라인

* 이 문서는 LLM이 프로젝트의 맥락을 정확히 이해하고, 더 효율적이며 프로젝트에 특화된 도움을 제공하도록 돕기 위해 작성되었습니다.

---

## 프로젝트 개요 및 목표

* 프로젝트 이름: 바로셈 (BaroSem)
* 목표: 사용자에게 빠르고 정확하며, 신뢰할 수 있는 전문화된 웹 계산기 서비스를 제공하여 일상생활 및 특정 분야(금융, 건강, 부동산 등)에서의 계산 편의성을 극대화합니다.
* 핵심 가치: '정확성', '편의성', '신뢰성', '시각적 명료성', '개인화된 경험'
* 디자인 톤 앤 매너: 모던하고 깔끔하며, 직관적인 사용자 경험을 제공하는 미니멀리즘 디자인을 지향합니다. 불필요한 요소는 제거하고, 계산 결과와 정보 전달에 집중합니다.
* 대상 사용자: 복잡한 계산을 자주 필요로 하는 일반 사용자, 특정 전문 분야(금융 종사자, 부동산 투자자, 건강 관리 관심자 등)의 계산 솔루션을 찾는 사용자
* 주요 경쟁 서비스: 일반 포털 사이트 내장 계산기, 특정 분야 전문 계산기 웹사이트 (예: 부동산 계산기, 대출 계산기 전문 사이트).
* 비즈니스 모델: 광고 수익 (구글 애드센스 등), 프리미엄 유료 기능/구독 (광고 제거, 고급 분석 기능, 계산 기록 무제한 저장 등), 제휴 마케팅 (계산 결과와 연관된 금융 상품, 부동산 서비스 등).
* 향후 확장 계획 (Roadmap):
  * 1단계 출시 후 계획: 모바일 반응형 디자인 고도화 및 전용 모바일 앱 (하이브리드 앱) 개발, 사용자 맞춤형 대시보드 기능 강화, AI 기반 계산 시나리오 추천 기능 추가.
  * 기술적 스케일업/스케일아웃 전략: 서버리스 데이터베이스(Neon)를 활용한 자동 스케일링, Vercel의 서버리스 함수를 통한 백엔드 로직 확장, CDN을 통한 정적 자산 캐싱 강화.
* 프로젝트 깃헙 레포지토리: <https://github.com/0disoft/barosem>

---

## 기술 스택 및 설정 전략

* 개발 유형: 웹 애플리케이션/사이트
* 프론트엔드/풀스택 프레임워크: SvelteKit
  * 핵심 기능 라이브러리/서비스:
    * 상태 관리: Svelte의 내장 스토어 (최소한의 전역 상태 관리에 활용)
    * 폼 관리 및 유효성 검사: SvelteKit의 서버 액션 및 Zod (강력하고 타입 안전한 폼 처리)
* 스타일링 툴: shadcn-svelte (UnoCSS 기반)
* 백엔드: SvelteKit (내장된 서버 액션 및 엔드포인트 활용)
  * 핵심 기능 라이브러리/서비스:
    * 인증: SvelteKit 내에서 직접 구현 또는 Supabase Auth 연동 고려
    * 이메일 전송: Nodemailer (SMTP 서비스 연동)
* 런타임 환경 및 패키지 매니저: Bun (주요 런타임 및 올인원 개발 도구), pnpm (안정적인 서드파티 패키지 관리 보조)
* 데이터베이스: PostgreSQL (Neon 배포 서비스 활용)
  * ORM/데이터베이스 클라이언트: Prisma
* 배포 전략 및 플랫폼: Vercel (통합 아키텍처 배포)
  * CI/CD 파이프라인: Vercel 내장 Git 연동 CI/CD (GitHub 연동 자동 배포)
* 지역화 (l10n) 전략: 다국어 페이지 지원 및 언어 전환 버튼 기능 구현, 기본 언어: 영어 (접속 국가 언어로 자동 선택 지원), 번역 파일 수동 준비 (LLM을 이용한 직접 번역 포함)
  * 관련 라이브러리/서비스: `svelte-i18n` (SvelteKit 환경에서 다국어 지원에 적합)
* API 클라이언트 (테스트 및 문서화): Bruno (텍스트 기반 API 테스트 및 컬렉션 관리)
* 데이터 유효성 검사: Zod

---

## 개발 환경

* OS: 윈도우 11
* IDE: VS Code
* 터미널: Git Bash

---

## 구현해야 할 페이지와 기능

* 핵심 페이지:
  * 메인 페이지 (홈):
    * 주요 계산기 목록 및 검색창
    * 카테고리별 계산기 분류
    * 서비스 소개 및 강점 요약
    * 최신 업데이트/뉴스 공지
  * 개별 계산기 상세 페이지:
    * 명확하고 직관적인 계산 입력 필드 (단위 선택, 고급 옵션 포함)
    * 실시간 입력 유효성 검사 및 사용자 정의 오류 메시지 표시 (SvelteKit의 fail 함수 활용)
    * 계산 결과의 시각적 표시 (그래프, 표, 요약 카드 등)
    * 상세 분석 및 해석 제공
    * 관련 정보 및 팁, 제휴 링크
    * 계산 결과 저장, PDF/이미지 내보내기, 소셜 미디어 공유
  * 내 계산 (사용자 대시보드):
    * 저장된 계산 기록 목록 및 검색/필터 기능
    * 자주 사용하는 계산기 목록
    * 개인 설정 관리 (화폐 단위, 기본 측정 단위 등)
    * 프리미엄 기능 관리 (구독 상태 확인, 기능 활성화)
  * 정보 및 고객 지원 페이지:
    * 서비스 소개/회사 소개
    * 자주 묻는 질문 (FAQ)
    * 문의하기/고객 지원 채널 (이메일, 문의 폼)
    * 개인정보처리방침 및 이용약관
    * 각 계산기별 로직/공식 설명 (결과 신뢰도 향상)
* 주요 기능:
  * 사용자 인증 및 계정 관리 (회원가입, 로그인, 비밀번호 재설정)
  * 계산 결과 저장 및 불러오기 (개인화 기능)
  * 다양한 카테고리별 전문 계산기 구현 (예: 대출 이자, 부동산 취득세, BMI, 환율 등)
  * 계산 결과의 시각화 (차트, 그래프) 및 상세 분석
  * 서버 측 폼 유효성 검사 및 에러 메시지 처리 (SvelteKit 서버 액션, Zod)
  * 다국어 지원 및 언어 전환
  * 검색 엔진 최적화 (SEO)를 위한 SSR/SSG 활용
  * 모든 페이지 및 기능에 대한 강력한 웹 접근성(A11y) 보장
* 추가 고려 기능 (선택 사항):
  * 실시간 알림 (웹소켓 기반: 특정 계산 결과 변화, 업데이트 알림 등)
  * 다중 파일 업로드 기능 (예: 엑셀 파일로 일괄 계산 데이터 업로드)
  * 소셜 공유 기능 고도화 (계산 결과를 위한 맞춤형 이미지 생성 포함)
  * AI 기반 계산 시나리오 추천 고도화 (사용자 패턴 분석 기반)
  * 사용자 등급별 혜택 시스템 (프리미엄 구독자를 위한 차등 혜택)

---

## 코딩 규칙 및 스타일

* 변수/함수명: 명확하고 의미를 쉽게 유추할 수 있는 이름을 사용합니다. (예: `getData` 대신 `fetchUserProfileData`)
* 코드 라인 길이: 한 줄의 최대 길이는 80자 (띄어쓰기 포함)를 지킵니다. (예외: 긴 URL, 코드 블록, 테이블, 제목)
* 함수 길이: 함수의 최대 길이는 50라인 (주석 및 줄바꿈 포함)을 지킵니다.
* 들여쓰기: 특별한 경우가 아니라면 2칸 공백을 사용합니다.
* 커밋 메시지: Gitmoji 형식을 사용한 영어 코멘트를 작성합니다.
* Single Source of Truth: 서비스 이름, API 엔드포인트, 주요 설정 값 등은 코드 곳곳에 하드코딩하지 않습니다. 모든 설정은 별도의 설정 파일이나 상수 모듈에 모아서, 딱 한 군데만 수정하면 전체에 적용되도록 만듭니다.
* 모듈성: 코드를 작고 응집도 높은 모듈로 분리하여 재사용성과 유지보수성을 높입니다.
* 가독성: 다른 개발자가 코드를 쉽게 이해할 수 있도록 작성합니다.
* 성능: 특히 고빈도 호출이 예상되는 API나 데이터 처리 로직에서는 성능을 최우선으로 고려합니다.
* 보안: 사용자 데이터 보호, 인증/인가, 입력 유효성 검사 등 보안을 항상 염두에 둡니다. (프로젝트 특성에 따른 추가 보안 고려사항 명시 가능: 예: XSS/CSRF 방지, SQL Injection 방지, 비밀번호 해싱)
* 데이터 정확성: 제공되는 데이터(특히 계산 결과)는 최신 법규와 공식 데이터를 기반으로 최대한의 정확성을 보장해야 합니다. 부동 소수점 오류 방지를 위한 정밀한 숫자 연산 라이브러리 사용을 권장합니다.
* 에러 처리: 모든 잠재적인 에러 상황에 대해 견고하고 명확한 에러 처리 로직을 구현합니다. (예: 서버 측 폼 액션에서 `fail` 함수를 사용하여 개발자에게 구체적인 오류 메시지 전달)
* 접근성 (A11y): 웹 애플리케이션 개발 시 웹 접근성 표준을 준수하여 모든 사용자가 쉽게 접근하고 이용할 수 있도록 합니다. (처음부터 강력한 접근성 보장)
* 주석 작성 규칙: 주석은 '왜' 이 코드가 존재하는지, 코드를 변경했다면 '왜' 변경했는지, 특정 비즈니스 논리나 기술적 절충안 등 코드만으로 설명하기 어려운 배경 정보를 제공하는데 사용합니다.
* 마크다운 작성 규칙: 다음은 자주 발생하는 마크다운 오류이므로 항상 유의하여 작성합니다.
  * `MD030/list-marker-space`: 리스트 마커 다음에는 정확히 한 칸의 공백을 사용합니다.
  * `MD022/blanks-around-headings`: 제목(Heading)의 위와 아래에는 항상 한 줄씩 비워둡니다.
  * `MD047/single-trailing-newline`: 파일의 마지막은 항상 하나의 개행 문자로 끝나야 합니다.
  * `MD024/no-duplicate-heading`: 한 문서 내에서 동일한 내용의 제목을 중복으로 사용하지 않습니다.
  * `MD007/ul-indent`: 중첩되지 않은 리스트는 2칸 들여쓰기를 사용합니다.

---

## 테스트 전략

* 단위 테스트: 개별 함수나 컴포넌트의 동작을 검증합니다. (예: Vitest, Jest)
* 통합 테스트: 여러 모듈이나 컴포넌트가 함께 작동하는 방식을 검증합니다.
* E2E (End-to-End) 테스트: 사용자 시나리오를 기반으로 전체 시스템의 흐름을 검증합니다. (예: Playwright)
  * Playwright 활용 지침: `waitForTimeout`과 같은 임의의 지연을 피하고, Playwright의 내장된 자동 대기 메커니즘과 웹 우선 어설션의 자동 재시도 기능을 전적으로 신뢰합니다.
* 테스트 코드 커버리지 목표: (예: 80% 이상)

---

## 배포 및 운영 전략

* 배포 파이프라인: (예: Git push 시 Vercel 자동 배포, Production/Staging 환경 분리)
* 모니터링 및 로깅: 서비스 운영 중 발생할 수 있는 문제점을 빠르게 감지하고 해결하기 위한 시스템 (예: Sentry, Datadog)
* 백업 및 복구 전략: 데이터 손실 방지를 위한 데이터베이스 백업 주기 및 복구 절차
* 성능 모니터링: (예: Lighthouse, Web Vitals, Vercel Analytics)

---

## AI 지식 베이스 및 문서화

LLM의 학습 데이터 한계(Knowledge Cutoff)를 극복하고, 프로젝트의 기술적 맥락과 최신 정보를 정확하게 파악하기 위해 이 중앙화된 지식 베이스를 관리합니다. 코드를 분석하거나 생성할 때, 항상 이 내부 지식 베이스의 문서를 가장 먼저 확인하십시오.

* **위치**: LLM과 관련된 모든 문서는 `/.gemini/` 폴더 아래에 중앙화하여 관리합니다.

### 1. 프레임워크 최신 정보 (`/.gemini/.changelogs/` 및 `/.gemini/.context7/`)

* **목적**: LLM의 지식 격차를 해소하고, 최신 프레임워크 정보를 효과적으로 활용하기 위해 두 가지 유형의 문서를 관리합니다.
  * `/.gemini/.changelogs/`: 주요 프레임워크의 분기별(예: 25년 1분기, 2분기) 최신 업데이트 중, 반드시 알아야 할 핵심 변경 사항이나 주요 기능 추가 내용을 요약하여 저장합니다.
  * `/.gemini/.context7/`: `Context7` MCP를 통해 방대한 공식 문서를 검색하기 전, 로컬에서 자주 사용하는 기능의 일반적인 사용법이나 코드 스니펫을 빠르게 확인하기 위한 용도로 사용됩니다.
* **LLM 활용 가이드**:
  * 프레임워크의 최신 버전과 관련된 작업을 수행할 때는 먼저 `/.gemini/.changelogs/` 폴더를 확인하여 중요한 변경 사항(breaking changes 등)을 코드에 반영하십시오.
  * 특정 기능의 기본적인 사용법이나 예제가 필요할 때는 `/.gemini/.context7/` 폴더의 문서를 우선적으로 참조하여 빠르게 정보를 얻고, 더 상세한 내용이 필요할 경우에 `Context7` MCP를 활용하십시오.

### 2. 아키텍처 결정 기록 (`/.gemini/adr/`)

* **목적**: "왜(Why)" 특정 기술 스택이나 설계 패턴을 선택했는지 등, 프로젝트의 중요한 기술적 결정에 대한 이유와 배경을 기록합니다.
* **내용**: `001-monorepo-structure-decision.md` 와 같이 번호가 매겨진 마크다운 파일로 관리됩니다.
* **LLM 활용 가이드**: 새 ADR 작성 시 `_template.md` 파일을 복사하여 형식을 유지하십시오. 코드 제안 시에는 이 문서에 기록된 제약 조건과 역사적 맥락을 반드시 고려하십시오.

### 3. API 명세 (`/.gemini/api/`)

* **목적**: 주요 API 엔드포인트의 요청/응답 형식, 파라미터, 인증 요구사항, 반환 에러 코드 등을 명확하게 정의합니다.
* **내용**: `authentication.md`, `products.md` 와 같이 기능별로 파일이 분리되어 있습니다.
* **LLM 활용 가이드**: 새 API 문서 작성 시 `_template.md` 파일을 복사하여 구조를 유지하십시오. API 호출 또는 신규 엔드포인트 구현 시, 이 명세를 기준으로 정확한 코드를 생성하십시오.

### 4. 데이터 흐름 (`/.gemini/data-flow/`)

* **목적**: 사용자의 특정 행동이 시스템 전체(프론트엔드, 백엔드, 데이터베이스)에서 어떻게 처리되는지 그 과정을 기록합니다.
* **내용**: `checkout-process.md` 와 같이 핵심 사용자 시나리오별로 파일이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 흐름도 작성 시 `_template.md` 파일을 참고하십시오. 풀스택 기능 개발 및 디버깅 시, 이 흐름도를 바탕으로 시스템 간 상호작용을 파악하고 코드를 작성하십시오.

### 5. 테스트 전략 (`/.gemini/testing/`)

* **목적**: 프로젝트의 테스트 철학, 종류별 테스트 작성법, 모킹(mocking) 가이드라인 등을 정의하여 코드 품질과 일관성을 확보합니다.
* **내용**: 테스트 전략, 종류별 가이드, 모킹 방법 등이 기술됩니다.
* **LLM 활용 가이드**: 새 테스트 가이드 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 이 가이드라인에 따라 적절한 테스트 코드를 함께 생성하십시오.

### 6. 배포 가이드 (`/.gemini/deployment/`)

* **목적**: CI/CD 파이프라인의 흐름, 필수 환경 변수, 빌드 및 배포 과정을 문서화합니다.
* **내용**: 환경별 구성, 필수 환경 변수 목록, 배포 과정 등이 기술됩니다.
* **LLM 활용 가이드**: 새 배포 문서 작성 시 `_template.md` 파일을 참고하십시오. 배포 관련 스크립트나 설정 파일 수정 시, 이 문서를 참조하여 운영 환경에 영향을 주지 않도록 하십시오.

### 7. 공통 코드 패턴 (`/.gemini/patterns/`)

* **목적**: 프로젝트 전반에서 반복적으로 사용되는 고유한 코드 패턴이나 아키텍처 "레시피"를 기록하여 재사용성과 일관성을 높입니다.
* **내용**: 커스텀 훅, 상태 관리 로직 등 프로젝트 고유의 구현 패턴들이 정리되어 있습니다.
* **LLM 활용 가이드**: 새 패턴 문서 작성 시 `_template.md` 파일을 참고하십시오. 새로운 기능을 개발할 때, 먼저 이 디렉토리에서 재사용 가능한 패턴이 있는지 확인하고 적용하십시오.

### 8. UI/UX 가이드라인 (`/.gemini/ui-ux-guidelines/`)

* **목적**: 디자인 시스템, 컴포넌트 사용 원칙, 색상 팔레트, 타이포그래피 등 프론트엔드 개발 시 지켜야 할 규칙을 제공합니다.
* **내용**: 컴포넌트별 사용법, 디자인 토큰, 접근성 규칙 등이 기술됩니다.
* **LLM 활용 가이드**: 새 가이드라인 작성 시 `_template.md` 파일을 참고하십시오. 새로운 UI를 생성하거나 수정할 때, 이 가이드라인을 준수하여 디자인 통일성을 유지하십시오.

---

## 프로젝트 제약 사항 및 특이 사항

* 기술적 제약 사항: 없음
* 예산 제약 사항: 클라우드 서비스 비용을 최소화하며, 초기 단계에서는 무료 또는 저가형 플랜 우선 활용.
* 시간 제약 사항: 1단계 MVP(Minimum Viable Product)는 3개월 이내 출시 목표.
* 특이 사항: 계산기의 정확성이 매우 중요하므로, 부동 소수점 오류 방지를 위한 정밀한 숫자 연산(`decimal.js` 또는 `big.js` 같은 라이브러리 활용)에 특별히 주의해야 합니다. 금융 및 세금 관련 계산기는 최신 법규와 정책을 주기적으로 업데이트해야 합니다.
